{"name":"Actor Emitter","tagline":"ActorEmitter.js, lightweight, independent, async and scope-full event emitter library for JavaScript","body":"# ActorEmitter.js\r\n\r\n_Actoremitter.js_ is lightweight, independent, scope-full, event emitter library with some features.\r\n\r\n## Why\r\n\r\nThis package is meant to be single instance, lightweight, async and scope-full event emitter, in order to provide communication between objects in differbuild ent scopes.\r\nBinding on an event, maintains the worker scope, so they can continue to process the call in a non blocking way, with the e.next() method.\r\n\r\n### Use actoremitter to structure your code\r\n\r\nWe believe that async programming is a key feature of JavaScript code organization. \r\n\r\nWrite all of it in an asynchronous way is better than just rely asynchronous operations.\r\n**Web is not sync**\r\n**UI is not sync**\r\n**User Interactions are not sync**\r\n\r\nActor emitter helps you build better apps, async based, maintaining scope and a single dispatcher event emitter\r\n\r\n## How\r\n\r\nGet the scope\r\n    \r\n    var emitter = require('actor-emitter'),\r\n\r\nEmitting events\r\n\r\n    emitter.trigger('key', data);\r\n    emitter.bind('key', data);\r\n\r\nCalling next operation (it calls the function asynchronously)\r\n\r\n    emitter.next(function, data);\r\n\r\nPromise like\r\n\r\n    emitter.wait('promisse', data)\r\n           .then(function callback(data) { \r\n               //...\r\n           });\r\n    \r\n    emitter.bind('promisse', function(data, cb) {\r\n\r\n        cb('something');\r\n    });\r\n\r\n## How to Use It\r\n\r\nActor emitter is single instance, so it listens and emits the same events all across your app.\r\n\r\n    var emitter = require('actor-emitter');\r\n\r\nCheck this websocket implementation with actor-emitter!\r\n\r\n    var WebSocketClient = require('websocket').client,\r\n        emitter = require('actor-emitter'),\r\n        client = new WebSocketClient();\r\n\r\n    var _connection = null;\r\n\r\n    var _wsSend = function (data) {\r\n\r\n        try {\r\n\r\n    \t    _connection.sendUTF(data);\r\n    \t    console.log('-> ', data);\r\n\r\n        } catch (err) {\r\n\r\n    \t    console.error(err);\r\n        }\r\n    }\r\n\r\n    var wsSend = function (data) {\r\n\r\n        data = JSON.stringify(data);\r\n\r\n        // declare next function call, with scope and non blocking\r\n        emitter.next(_wsSend, data);\r\n    };\r\n\r\n    var wsOnMessage = function (data) {\r\n\r\n        var key = data.header + ':' + data.action + (data.__code__ ? ':' + data.__code__ : '');\r\n\r\n        emitter.trigger(key, data);\r\n    };\r\n\r\n    emitter.bind('socket:send', wsSend);\r\n\r\n    client.on('connectFailed', function(error) {\r\n\r\n        console.log('Connect Error: ' + error.toString());\r\n    });\r\n\r\n    client.on('connect', function(connection) {\r\n\r\n        console.log('WebSocket Client Connected');\r\n\r\n        connection.on('error', function(error) {\r\n\r\n    \t    console.log(\"Connection Error: \" + error.toString());\r\n        });\r\n\r\n        connection.on('close', function() {\r\n\r\n    \t    console.log('Connection Closed');\r\n        });\r\n\r\n        connection.on('message', function(message) {\r\n\r\n    \t    if (message.type === 'utf8') {\r\n\r\n    \t        console.log('<- ',  message.utf8Data);\r\n\r\n    \t        emitter.next(wsOnMessage, JSON.parse(message.utf8Data));\r\n    \t        emitter.trigger('socket:onmessage', JSON.parse(message.utf8Data));\r\n    \t    }\r\n        });\r\n\r\n        _connection = connection;\r\n\r\n        emitter.trigger('socket:onopen', connection);\r\n    });\r\n\r\n    client.connect('ws://someserver:8888/');\r\n\r\n\r\nIts all assync, non-block and easy\r\n\r\nThen, a worker should be like:\r\n\r\n    var emitter = require('actor-emitter'),\r\n    uuid     = require('node-uuid');\r\n\r\n    var worker = (function() {\r\n\r\n        var _id;\r\n\r\n        var onAuthenticationRequested = function (data) {\r\n\r\n    \t    _id = uuid();\r\n    \t    data._id = _id;\r\n    \t    data.appKey = 'myapp';\r\n\r\n            // send authentication request!\r\n    \t    emitter.trigger('socket:send', data);\r\n        };\r\n\r\n        var requestUserPublicProfile = function () {\r\n\r\n            var data = {\r\n                header: 'myapp',\r\n                action: 'user_get_public',\r\n                nick: 'mynick'\r\n            }\r\n\r\n            emitter.trigger('socket.send', data);\r\n        }\r\n\r\n        emitter.bind('authentication:announce', onAuthenticationRequested);\r\n        emitter.bind('authentication:announce:200', requestUserPublicProfile);\r\n    }\r\n\r\n\r\nThat example outputs something like this, assuming your server requests an authentication when connected\r\n\r\n    <-  {\"action\":\"announce\",\"header\":\"authentication\"}\r\n    ->  {\"action\":\"announce\",\"header\":\"authentication\",\"_id\":\"77e5b21e-4494-481c-9591-621680bf0772\",\"appKey\":\"myapp\"}\r\n    <-  {\"action\":\"announce\",\"header\":\"authentication\",\"__code__\":200}\r\n    ->  {\"header\":\"myapp\",\"action\":\"user_get_public\",\"nick\":\"mynick\"}\r\n    <-  ...\r\n\r\nThats it.\r\n\r\nInstall it via npm\r\n\r\n    npm install actor-emitter\r\n\r\nTo include it in a nodejs code isnt much harder\r\n\r\n    var aEmitter = require('actor-emitter')\r\n\r\nMIT license.\r\nIf you hit bugs, fill issues on github.\r\nFeel free to fork, modify and have fun with it :)","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}